<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Hyperbolic Display</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-width: 200px;
            max-width: 280px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            overflow-x: hidden;
            color: #fff;
            font-size: 12px;
            z-index: 1000;
            -webkit-overflow-scrolling: touch;
        }
        
        .controls::-webkit-scrollbar {
            width: 6px;
        }
        
        .controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .controls::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .controls-toggle {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 1001;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
        }
        .controls h3 {
            font-size: 13px;
            margin-bottom: 16px;
            font-weight: 600;
        }
        .control-section {
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .control-section-title {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            transition: color 0.2s;
        }
        .control-section-title:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        .control-section-title::after {
            content: '▼';
            font-size: 9px;
            transition: transform 0.2s;
            opacity: 0.6;
        }
        .control-section.collapsed .control-section-title::after {
            transform: rotate(-90deg);
        }
        .control-section-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
            max-height: 1000px;
            opacity: 1;
        }
        .control-section.collapsed .control-section-content {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
        }
        .control {
            margin-bottom: 14px;
        }
        .control label {
            display: block;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 6px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }
        
        .control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            border: none;
            touch-action: manipulation;
        }
        
        .control input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .control input[type="range"]::-moz-range-track {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .control select {
            touch-action: manipulation;
        }
        
        .control button {
            touch-action: manipulation;
        }
        
        /* Tablet styles */
        @media (max-width: 1024px) and (min-width: 768px) {
            .controls {
                max-width: 240px;
                padding: 16px;
                font-size: 11px;
            }
            
            .control input[type="range"] {
                height: 8px;
            }
            
            .control input[type="range"]::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
            
            .control input[type="range"]::-moz-range-thumb {
                width: 18px;
                height: 18px;
            }
        }
        
        /* Mobile styles */
        @media (max-width: 767px) {
            .controls-toggle {
                display: flex;
            }
            
            .controls {
                top: 0;
                right: 0;
                left: 0;
                bottom: 0;
                max-width: 100%;
                max-height: 100vh;
                border-radius: 0;
                padding: 60px 16px 20px 16px;
                transform: translateX(100%);
                transition: transform 0.3s ease-out;
            }
            
            .controls.open {
                transform: translateX(0);
            }
            
            .controls h3 {
                font-size: 14px;
            }
            
            .control-section-title {
                font-size: 12px;
                padding: 8px 0;
                margin-bottom: 8px;
            }
            
            .control {
                margin-bottom: 16px;
            }
            
            .control label {
                font-size: 12px;
                margin-bottom: 8px;
            }
            
            .control input[type="range"] {
                height: 10px;
            }
            
            .control input[type="range"]::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }
            
            .control input[type="range"]::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }
            
            .control select {
                padding: 8px;
                font-size: 14px;
            }
            
            #hideGridBtn {
                padding: 12px;
                font-size: 14px;
            }
        }
        
        /* Small mobile styles */
        @media (max-width: 480px) {
            .controls-toggle {
                width: 44px;
                height: 44px;
                top: 12px;
                right: 12px;
            }
            
            .controls {
                padding: 56px 12px 16px 12px;
            }
        }
        
        /* Prevent text selection on mobile during interactions */
        @media (max-width: 767px) {
            body {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }
            
            .control-section-title,
            .control label,
            .control select,
            .control input {
                -webkit-user-select: none;
                user-select: none;
            }
        }
        }
        .value {
            min-width: 45px;
            text-align: right;
            font-size: 11px;
            font-variant-numeric: tabular-nums;
        }
        .debug {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
        }
        .debug.hidden {
            display: none;
        }
        .controls button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .controls button:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls select {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="debug" id="debug"></div>
    <button class="controls-toggle" id="controlsToggle" aria-label="Toggle controls">☰</button>
    <div class="controls" id="controls">
        <h3>Controls</h3>
        
        <!-- View & Display -->
        <div class="control-section">
            <div class="control-section-title">View & Display</div>
            <div class="control-section-content">
            <div class="control">
                <label>Stage Shape</label>
                <div class="control-row">
                    <select id="stageShape" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px; border-radius: 4px;">
                        <option value="0">Sphere</option>
                        <option value="1">Plane</option>
                        <option value="2">Cylinder</option>
                        <option value="3">Torus</option>
                        <option value="4">Box</option>
                        <option value="5">Cone</option>
                    </select>
                </div>
            </div>
            <div class="control">
                <label>Mask Shape</label>
                <div class="control-row">
                    <select id="maskShape" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px; border-radius: 4px;">
                        <option value="0">Circle</option>
                        <option value="1">Square</option>
                        <option value="2">Rounded Square</option>
                        <option value="3">Diamond</option>
                        <option value="4">Hexagon</option>
                        <option value="5">Star</option>
                        <option value="6">Ellipse</option>
                    </select>
                </div>
            </div>
            <div class="control">
                <label>Display Mode</label>
                <div class="control-row">
                    <select id="displayMode" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px; border-radius: 4px;">
                        <option value="0">Hyperbolic</option>
                        <option value="1">Parabolic</option>
                        <option value="2">Elliptical</option>
                    </select>
                </div>
            </div>
            <div class="control">
                <label>Zoom</label>
                <div class="control-row">
                    <input type="range" id="zoom" min="0.1" max="2" step="0.1" value="0.8">
                    <span class="value" id="zoomVal">0.8</span>
                </div>
            </div>
            <div class="control">
                <label>Curvature</label>
                <div class="control-row">
                    <input type="range" id="curvature" min="0.1" max="2" step="0.1" value="1.0">
                    <span class="value" id="curvatureVal">1.0</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Fractal Pattern -->
        <div class="control-section">
            <div class="control-section-title">Fractal Pattern</div>
            <div class="control-section-content">
            <div class="control">
                <label>Fractal Type</label>
                <div class="control-row">
                    <select id="fractalType" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px; border-radius: 4px;">
                        <option value="0" selected>Wave Pattern</option>
                        <option value="1">Plasma Energy</option>
                        <option value="2">Flow Field</option>
                        <option value="3">Organic Growth</option>
                        <option value="4">Distortion Waves</option>
                        <option value="5">Spiral</option>
                        <option value="6">Voronoi</option>
                        <option value="7">Noise Clouds</option>
                    </select>
                </div>
            </div>
            <div class="control">
                <label>Iterations</label>
                <div class="control-row">
                    <input type="range" id="iterations" min="1" max="100" step="1" value="40">
                    <span class="value" id="iterationsVal">40</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Animation -->
        <div class="control-section">
            <div class="control-section-title">Animation</div>
            <div class="control-section-content">
            <div class="control">
                <label>Time Speed</label>
                <div class="control-row">
                    <input type="range" id="timeSpeed" min="0" max="2" step="0.1" value="0.3">
                    <span class="value" id="timeSpeedVal">0.3</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Lighting -->
        <div class="control-section">
            <div class="control-section-title">Lighting</div>
            <div class="control-section-content">
            <div class="control">
                <label>Brightness</label>
                <div class="control-row">
                    <input type="range" id="bright" min="0" max="100" step="1" value="50">
                    <span class="value" id="brightVal">50%</span>
                </div>
            </div>
            <div class="control">
                <label>Bump Strength</label>
                <div class="control-row">
                    <input type="range" id="bumpStrength" min="0" max="1" step="0.05" value="0.3">
                    <span class="value" id="bumpStrengthVal">0.30</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Color -->
        <div class="control-section">
            <div class="control-section-title">Color</div>
            <div class="control-section-content">
            <div class="control">
                <label>Hue</label>
                <div class="control-row">
                    <input type="range" id="hue" min="0" max="1" step="0.01" value="0">
                    <span class="value" id="hueVal">0.00</span>
                </div>
            </div>
            <div class="control">
                <label>Color Scheme</label>
                <div class="control-row">
                    <select id="colorScheme" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px; border-radius: 4px;">
                        <option value="monochromatic">Monochromatic</option>
                        <option value="analogous">Analogous</option>
                        <option value="complementary">Complementary</option>
                        <option value="splitComplementary">Split Complementary</option>
                        <option value="triadic">Triadic</option>
                        <option value="square">Square</option>
                        <option value="rectangular">Rectangular</option>
                    </select>
                </div>
            </div>
            <div class="control">
                <label>Color Range</label>
                <div class="control-row">
                    <input type="range" id="colorRange" min="0" max="2" step="0.1" value="1.0">
                    <span class="value" id="colorRangeVal">1.0</span>
                </div>
            </div>
            <div class="control">
                <label>Blend Mode</label>
                <div class="control-row">
                    <select id="blendMode" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 4px; border-radius: 4px;">
                        <option value="0">Normal</option>
                        <option value="1">Multiply</option>
                        <option value="2">Screen</option>
                        <option value="3">Overlay</option>
                        <option value="4">Soft Light</option>
                        <option value="5">Hard Light</option>
                        <option value="6">Color Dodge</option>
                        <option value="7">Color Burn</option>
                        <option value="8">Linear Dodge (Add)</option>
                        <option value="9">Linear Burn</option>
                        <option value="10">Vivid Light</option>
                        <option value="11">Linear Light</option>
                        <option value="12">Difference</option>
                        <option value="13">Exclusion</option>
                    </select>
                </div>
            </div>
            <div class="control">
                <label>Blend Percentage</label>
                <div class="control-row">
                    <input type="range" id="blendPercentage" min="0" max="100" step="1" value="100">
                    <span class="value" id="blendPercentageVal">100%</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Fluid Dynamics -->
        <div class="control-section">
            <div class="control-section-title">Fluid Dynamics</div>
            <div class="control-section-content">
            <div class="control">
                <label>Fluid Intensity</label>
                <div class="control-row">
                    <input type="range" id="fluid" min="0" max="3" step="0.1" value="1.0">
                    <span class="value" id="fluidVal">1.0</span>
                </div>
            </div>
            <div class="control">
                <label>Flow Speed</label>
                <div class="control-row">
                    <input type="range" id="flowSpeed" min="0" max="3" step="0.1" value="1.0">
                    <span class="value" id="flowVal">1.0</span>
                </div>
            </div>
            <div class="control">
                <label>Viscosity</label>
                <div class="control-row">
                    <input type="range" id="viscosity" min="0" max="1" step="0.05" value="0.3">
                    <span class="value" id="viscVal">0.3</span>
                </div>
            </div>
            </div>
        </div>
        
        <button id="hideGridBtn" style="margin-top: 16px; width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; cursor: pointer;">Hide Grid</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) throw new Error('WebGL not supported');

        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance on mobile
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => {
            setTimeout(resize, 100); // Delay to ensure new dimensions are available
        });

        // ============================================
        // NAVIER-STOKES FLUID SIMULATION SETUP
        // ============================================
        
        // Simulation resolution (lower than screen for performance)
        const SIM_WIDTH = 256;
        const SIM_HEIGHT = 256;
        
        // Check for required WebGL extensions
        const extFloat = gl.getExtension('OES_texture_float');
        const extFloatLinear = gl.getExtension('OES_texture_float_linear');
        const extColorBufferFloat = gl.getExtension('WEBGL_color_buffer_float');
        
        if (!extFloat) {
            console.warn('OES_texture_float not supported - using fallback');
        }
        
        // Create textures for velocity field (ping-pong)
        function createTexture(width, height) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, 
                         extFloat ? gl.FLOAT : gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return tex;
        }
        
        // Create framebuffers
        function createFramebuffer(texture) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('Framebuffer incomplete');
            }
            return fb;
        }
        
        // Velocity field textures (ping-pong)
        const velocityTexA = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const velocityTexB = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const velocityFBA = createFramebuffer(velocityTexA);
        const velocityFBB = createFramebuffer(velocityTexB);
        
        // Pressure field textures (ping-pong)
        const pressureTexA = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const pressureTexB = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const pressureFBA = createFramebuffer(pressureTexA);
        const pressureFBB = createFramebuffer(pressureTexB);
        
        // Divergence texture
        const divergenceTex = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const divergenceFB = createFramebuffer(divergenceTex);
        
        // Dye/density texture (for visualization)
        const dyeTexA = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const dyeTexB = createTexture(SIM_WIDTH, SIM_HEIGHT);
        const dyeFBA = createFramebuffer(dyeTexA);
        const dyeFBB = createFramebuffer(dyeTexB);
        
        // Ping-pong state
        let velocityRead = velocityTexA;
        let velocityWrite = velocityTexB;
        let pressureRead = pressureTexA;
        let pressureWrite = pressureTexB;
        let dyeRead = dyeTexA;
        let dyeWrite = dyeTexB;
        
        function swapVelocity() {
            [velocityRead, velocityWrite] = [velocityWrite, velocityRead];
        }
        
        function swapPressure() {
            [pressureRead, pressureWrite] = [pressureWrite, pressureRead];
        }
        
        function swapDye() {
            [dyeRead, dyeWrite] = [dyeWrite, dyeRead];
        }
        
        // Full-screen quad for rendering to textures
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
        
        const vs = `attribute vec2 a_pos; varying vec2 v_uv; void main() { gl_Position = vec4(a_pos,0,1); v_uv = a_pos*0.5+0.5; }`;

        // ============================================
        // NAVIER-STOKES SHADER PROGRAMS
        // ============================================
        
        // 1. Advection Shader - transports velocity and dye through the velocity field
        const advectionFS = `
            precision highp float;
            uniform sampler2D u_velocity;
            uniform sampler2D u_source;
            uniform vec2 u_resolution;
            uniform float u_dt;
            uniform float u_dissipation;
            varying vec2 v_uv;
            
            void main() {
                vec2 uv = v_uv;
                vec2 velocity = texture2D(u_velocity, uv).xy;
                
                // Semi-Lagrangian advection: trace back in time
                vec2 advectedPos = uv - velocity * u_dt * u_resolution;
                
                // Sample source field at advected position
                vec4 source = texture2D(u_source, advectedPos);
                
                // Apply dissipation (decay)
                gl_FragColor = source * u_dissipation;
            }
        `;
        
        // 2. Diffusion Shader - applies viscosity (smooths velocity field)
        const diffusionFS = `
            precision highp float;
            uniform sampler2D u_velocity;
            uniform vec2 u_resolution;
            uniform float u_viscosity;
            uniform float u_dt;
            varying vec2 v_uv;
            
            void main() {
                vec2 uv = v_uv;
                vec2 texelSize = 1.0 / u_resolution;
                
                // Sample velocity at center and neighbors
                vec2 center = texture2D(u_velocity, uv).xy;
                vec2 L = texture2D(u_velocity, uv + vec2(-texelSize.x, 0.0)).xy;
                vec2 R = texture2D(u_velocity, uv + vec2(texelSize.x, 0.0)).xy;
                vec2 T = texture2D(u_velocity, uv + vec2(0.0, -texelSize.y)).xy;
                vec2 B = texture2D(u_velocity, uv + vec2(0.0, texelSize.y)).xy;
                
                // Laplacian (diffusion): average of neighbors minus center
                vec2 laplacian = (L + R + T + B - 4.0 * center);
                
                // Apply viscosity diffusion: v = v + viscosity * dt * ∇²v
                // Higher viscosity = more smoothing/damping
                float viscosityCoeff = u_viscosity * 10.0; // Scale for visibility
                vec2 velocity = center + laplacian * viscosityCoeff * u_dt;
                
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;
        
        // 3. Divergence Shader - computes divergence of velocity field
        const divergenceFS = `
            precision highp float;
            uniform sampler2D u_velocity;
            uniform vec2 u_resolution;
            varying vec2 v_uv;
            
            void main() {
                vec2 uv = v_uv;
                vec2 texelSize = 1.0 / u_resolution;
                
                // Sample velocity at neighboring points
                float L = texture2D(u_velocity, uv + vec2(-texelSize.x, 0.0)).x;
                float R = texture2D(u_velocity, uv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(u_velocity, uv + vec2(0.0, -texelSize.y)).y;
                float B = texture2D(u_velocity, uv + vec2(0.0, texelSize.y)).y;
                
                // Compute divergence: (∂u/∂x + ∂v/∂y)
                float divergence = 0.5 * ((R - L) + (T - B));
                
                gl_FragColor = vec4(divergence, 0.0, 0.0, 1.0);
            }
        `;
        
        // 4. Pressure Solver (Jacobi iteration) - solves Poisson equation
        const pressureFS = `
            precision highp float;
            uniform sampler2D u_pressure;
            uniform sampler2D u_divergence;
            uniform vec2 u_resolution;
            varying vec2 v_uv;
            
            void main() {
                vec2 uv = v_uv;
                vec2 texelSize = 1.0 / u_resolution;
                
                // Sample pressure at neighboring points
                float L = texture2D(u_pressure, uv + vec2(-texelSize.x, 0.0)).x;
                float R = texture2D(u_pressure, uv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(u_pressure, uv + vec2(0.0, -texelSize.y)).x;
                float B = texture2D(u_pressure, uv + vec2(0.0, texelSize.y)).x;
                
                // Sample divergence
                float div = texture2D(u_divergence, uv).x;
                
                // Jacobi iteration: p = (L + R + T + B - div) / 4
                float pressure = (L + R + T + B - div) * 0.25;
                
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
        `;
        
        // 5. Gradient Subtraction - makes velocity divergence-free
        const gradientSubtractFS = `
            precision highp float;
            uniform sampler2D u_velocity;
            uniform sampler2D u_pressure;
            uniform vec2 u_resolution;
            varying vec2 v_uv;
            
            void main() {
                vec2 uv = v_uv;
                vec2 texelSize = 1.0 / u_resolution;
                
                // Sample pressure gradient
                float pL = texture2D(u_pressure, uv + vec2(-texelSize.x, 0.0)).x;
                float pR = texture2D(u_pressure, uv + vec2(texelSize.x, 0.0)).x;
                float pT = texture2D(u_pressure, uv + vec2(0.0, -texelSize.y)).x;
                float pB = texture2D(u_pressure, uv + vec2(0.0, texelSize.y)).x;
                
                // Compute pressure gradient
                vec2 pressureGrad = vec2((pR - pL) * 0.5, (pT - pB) * 0.5);
                
                // Subtract gradient from velocity: v = v - ∇p
                vec2 velocity = texture2D(u_velocity, uv).xy;
                velocity -= pressureGrad;
                
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;
        
        // 6. Add Force Shader - adds external forces to velocity
        const addForceFS = `
            precision highp float;
            uniform sampler2D u_velocity;
            uniform vec2 u_force;
            uniform vec2 u_forcePos;
            uniform vec2 u_resolution;
            uniform float u_forceRadius;
            varying vec2 v_uv;
            
            void main() {
                vec2 uv = v_uv;
                vec2 pos = uv * u_resolution;
                vec2 diff = pos - u_forcePos;
                float dist = length(diff);
                
                vec2 velocity = texture2D(u_velocity, uv).xy;
                
                // Apply force with smooth falloff
                float forceStrength = exp(-dist * dist / (2.0 * u_forceRadius * u_forceRadius));
                velocity += u_force * forceStrength;
                
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        // Hyperbolic display using Poincaré disk model
        const fs = `
            precision highp float;
            uniform float u_time;
            uniform float u_zoom;
            uniform float u_curvature;
            uniform float u_iterations;
            uniform float u_bright;
            uniform float u_displayMode;
            uniform float u_hue;
            uniform mat3 u_rotation3D;
            uniform mat3 u_cameraRotation;
            uniform vec2 u_resolution;
            uniform float u_patternScale;  // Fixed scale factor for consistent pattern size across devices
            uniform float u_bumpStrength;  // Bump mapping strength (0-1)
            uniform float u_colorScheme;
            uniform float u_colorRange;
            uniform float u_fluidIntensity;
            uniform float u_flowSpeed;
            uniform float u_viscosity;
            uniform float u_showGrid;
            uniform sampler2D u_velocityField;  // Navier-Stokes velocity texture
            uniform sampler2D u_dyeField;       // Navier-Stokes dye texture
            uniform vec2 u_simResolution;       // Simulation texture resolution
            uniform float u_fractalType;        // Fractal type selector
            uniform float u_blendMode;          // Blend mode selector
            uniform float u_blendPercentage;    // Blend mode strength (0-1)
            uniform float u_stageShape;         // Stage shape selector
            uniform float u_maskShape;          // Mask shape selector
            varying vec2 v_uv;
            
            mat2 rotate2D(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat2(c, -s, s, c);
            }
            
            // Sample Navier-Stokes velocity field
            vec2 fluidFlow(vec2 uv, float time) {
                // Sample velocity from Navier-Stokes simulation
                vec2 velocity = texture2D(u_velocityField, uv).xy;
                
                // Scale by fluid intensity and flow speed
                velocity *= u_fluidIntensity * u_flowSpeed;
                
                // Viscosity is now handled in the simulation itself (diffusion step)
                // No need to apply it again here
                
                return velocity;
            }
            
            // Noise function for pattern generation
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            // Smooth noise
            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = noise(i);
                float b = noise(i + vec2(1.0, 0.0));
                float c = noise(i + vec2(0.0, 1.0));
                float d = noise(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            // Manual implementations of hyperbolic functions
            float tanh_impl(float x) {
                float exp2x = exp(2.0 * x);
                return (exp2x - 1.0) / (exp2x + 1.0);
            }
            
            float atanh_impl(float x) {
                return 0.5 * log((1.0 + x) / (1.0 - x));
            }
            
            // Convert 2D point to 3D sphere coordinates
            vec3 toSphere(vec2 p, float mode) {
                float r = length(p);
                
                // Different geometries for sphere mapping
                float sphereR;
                if (mode < 0.5) {
                    // Hyperbolic
                    if (r >= 0.999) r = 0.999;
                    float rHyper = atanh_impl(r) * u_curvature;
                    sphereR = tanh_impl(rHyper);
                } else if (mode < 1.5) {
                    // Parabolic
                    float rPara = r * r * u_curvature;
                    sphereR = sqrt(rPara / (1.0 + rPara)) * u_curvature;
                    sphereR = clamp(sphereR, 0.0, 0.999);
                } else {
                    // Elliptical
                    float rEllip = asin(clamp(r, 0.0, 0.999)) * u_curvature;
                    sphereR = sin(rEllip);
                    sphereR = clamp(sphereR, 0.0, 0.999);
                }
                
                // Map to sphere surface
                float theta = atan(p.y, p.x);
                float phi = acos(sphereR);
                
                // Convert to 3D coordinates
                float x = sin(phi) * cos(theta);
                float y = sin(phi) * sin(theta);
                float z = cos(phi);
                
                return vec3(x, y, z);
            }
            
            // Convert 2D point to 3D plane coordinates (flat)
            vec3 toPlane(vec2 p) {
                // Simple flat plane - just use XY coordinates, Z is depth
                float r = length(p);
                float depth = 1.0 - r; // Center is closer, edges are further
                return vec3(p.x, p.y, depth * 0.5);
            }
            
            // Convert 2D point to 3D cylinder coordinates
            vec3 toCylinder(vec2 p) {
                // Wrap around cylinder - X becomes angle, Y becomes height
                float angle = p.x * 3.14159; // -π to π
                float height = p.y;
                float radius = 0.8;
                
                float x = cos(angle) * radius;
                float y = height;
                float z = sin(angle) * radius;
                
                return vec3(x, y, z);
            }
            
            // Convert 2D point to 3D torus coordinates
            vec3 toTorus(vec2 p) {
                // Torus (donut) shape
                float majorRadius = 0.6;
                float minorRadius = 0.3;
                
                float u = p.x * 6.28318; // 0 to 2π
                float v = p.y * 6.28318; // 0 to 2π
                
                float x = (majorRadius + minorRadius * cos(v)) * cos(u);
                float y = (majorRadius + minorRadius * cos(v)) * sin(u);
                float z = minorRadius * sin(v);
                
                return vec3(x, y, z);
            }
            
            // Convert 2D point to 3D box/cube coordinates
            vec3 toBox(vec2 p) {
                // Box shape - map to cube faces
                float r = length(p);
                float angle = atan(p.y, p.x);
                
                // Map to cube surface
                vec3 pos;
                if (abs(p.x) > abs(p.y)) {
                    // Front or back face
                    pos = vec3(sign(p.x) * 0.8, p.y * 0.8, (1.0 - r) * 0.8);
                } else {
                    // Left or right face
                    pos = vec3(p.x * 0.8, sign(p.y) * 0.8, (1.0 - r) * 0.8);
                }
                
                return pos;
            }
            
            // Convert 2D point to 3D cone coordinates
            vec3 toCone(vec2 p) {
                float r = length(p);
                float angle = atan(p.y, p.x);
                
                // Cone: radius decreases with distance from center
                float radius = (1.0 - r) * 0.8;
                float height = r * 1.2 - 0.6;
                
                float x = cos(angle) * radius;
                float y = sin(angle) * radius;
                float z = height;
                
                return vec3(x, y, z);
            }
            
            // Stage shape selector - converts 2D UV to 3D position
            vec3 toStageShape(vec2 p, float displayMode) {
                if (u_stageShape < 0.5) {
                    // Sphere
                    return toSphere(p, displayMode);
                } else if (u_stageShape < 1.5) {
                    // Plane
                    return toPlane(p);
                } else if (u_stageShape < 2.5) {
                    // Cylinder
                    return toCylinder(p);
                } else if (u_stageShape < 3.5) {
                    // Torus
                    return toTorus(p);
                } else if (u_stageShape < 4.5) {
                    // Box
                    return toBox(p);
                } else {
                    // Cone
                    return toCone(p);
                }
            }
            
            // Convert 3D shape point back to 2D UV for pattern sampling
            // Applies camera rotation (moves grid pole) and grid rotation (pattern rotation)
            vec2 shapeToUV(vec3 shapePos) {
                // Apply camera rotation FIRST - this moves the grid's pole
                vec3 cameraRotated = u_cameraRotation * shapePos;
                
                // Apply grid rotation (pattern rotation)
                vec3 gridRotated = u_rotation3D * cameraRotated;
                
                // For sphere-like shapes, use stereographic projection
                if (u_stageShape < 0.5 || u_stageShape >= 1.5) {
                    // Sphere, Cylinder, Torus, Box, Cone - use stereographic projection
                    float denom = 1.0 + gridRotated.z;
                    if (abs(denom) < 0.001) return vec2(0.0);
                    return vec2(gridRotated.x / denom, gridRotated.y / denom);
                } else {
                    // Plane - use direct XY mapping with rotation
                    return vec2(gridRotated.x, gridRotated.y);
                }
            }
            
            // Mandelbrot set
            // Plasma/Energy pattern - dynamic, flowing energy fields
            float plasmaEnergyPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                // Multiple sine waves at different frequencies and angles (similar to wave pattern)
                float v1 = sin(length(p) * 20.0 * detailScale - time * 0.5) * 0.5 + 0.5;
                float v2 = sin(p.x * 15.0 * detailScale + p.y * (15.0 * 0.8) * detailScale + time * 0.3) * 0.5 + 0.5;
                float v3 = sin(p.y * 18.0 * detailScale - p.x * (18.0 * 0.55) * detailScale + time * 0.4) * 0.5 + 0.5;
                
                // Combine similar to wave pattern for consistent fluid behavior
                float plasma = v1 * v2 * 0.7 + v3 * 0.3;
                
                // Add noise for texture (same as wave pattern)
                float noise = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                plasma = mix(plasma, noise, 0.4);
                
                // Normalize to match wave pattern's range
                plasma = abs(plasma - 0.5) * 2.0;
                plasma = 1.0 - plasma;
                float original = (v1 + v2 + v3) / 3.0;
                plasma = mix(plasma, original, 0.5);
                
                return clamp(plasma, 0.0, 1.0);
            }
            
            // Flow field pattern - directional flow patterns
            float flowFieldPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                // Use similar structure to wave pattern for consistent fluid behavior
                float freq1 = 20.0 * detailScale;
                float freq2 = 15.0 * detailScale;
                float freq3 = 18.0 * detailScale;
                
                // Radial and angular components
                float dist = length(p);
                float angle = atan(p.y, p.x);
                
                float pattern1 = sin(dist * freq1 - time * 0.5) * 0.5 + 0.5;
                float pattern2 = sin(angle * 10.0 + dist * freq2 * 0.8 + time * 0.3) * 0.5 + 0.5;
                float pattern3 = sin(dist * freq3 - angle * 5.0 + time * 0.4) * 0.5 + 0.5;
                
                // Combine similar to wave pattern
                float flow = pattern1 * pattern2 * 0.7 + pattern3 * 0.3;
                
                // Add noise for texture
                float noise = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                flow = mix(flow, noise, 0.4);
                
                // Normalize to match wave pattern's range
                flow = abs(flow - 0.5) * 2.0;
                flow = 1.0 - flow;
                float original = (pattern1 + pattern2 + pattern3) / 3.0;
                flow = mix(flow, original, 0.5);
                
                return clamp(flow, 0.0, 1.0);
            }
            
            // Organic growth pattern - branching, organic structures
            float organicGrowthPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                // Use similar structure to wave pattern but with organic noise
                float freq1 = 20.0 * detailScale;
                float freq2 = 15.0 * detailScale;
                float freq3 = 18.0 * detailScale;
                
                // Combine sine waves with noise for organic feel
                float pattern1 = sin(length(p) * freq1 - time * 0.5) * 0.5 + 0.5;
                float pattern2 = sin(p.x * freq2 + p.y * (freq2 * 0.8) + time * 0.3) * 0.5 + 0.5;
                float pattern3 = sin(p.y * freq3 - p.x * (freq3 * 0.55) + time * 0.4) * 0.5 + 0.5;
                
                // Add organic noise (more prominent than wave pattern)
                float organicNoise = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                
                // Combine with more noise influence for organic texture
                float organic = pattern1 * pattern2 * 0.7 + pattern3 * 0.3;
                organic = mix(organic, organicNoise, 0.6); // More noise for organic feel
                
                // Normalize to match wave pattern's range
                organic = abs(organic - 0.5) * 2.0;
                organic = 1.0 - organic;
                float original = (pattern1 + pattern2 + pattern3) / 3.0;
                organic = mix(organic, original, 0.5);
                
                return clamp(organic, 0.0, 1.0);
            }
            
            // Distortion waves pattern - complex wave interference
            float distortionWavesPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                // Use similar structure to wave pattern for consistent fluid behavior
                float freq1 = 20.0 * detailScale;
                float freq2 = 15.0 * detailScale;
                float freq3 = 18.0 * detailScale;
                
                float pattern1 = sin(length(p) * freq1 - time * 0.5) * 0.5 + 0.5;
                float pattern2 = sin(p.x * freq2 + p.y * (freq2 * 0.8) + time * 0.3) * 0.5 + 0.5;
                float pattern3 = sin(p.y * freq3 - p.x * (freq3 * 0.55) + time * 0.4) * 0.5 + 0.5;
                
                // Add distortion using noise-warped coordinates
                vec2 distorted = p + vec2(
                    smoothNoise(p * 4.0 + time * 0.1) * 0.1,
                    smoothNoise(p * 4.0 - time * 0.15) * 0.1
                );
                float distortedPattern = sin(length(distorted) * freq1 * 0.8 - time * 0.5) * 0.5 + 0.5;
                
                // Combine patterns with distortion
                float distortion = pattern1 * pattern2 * 0.7 + pattern3 * 0.3;
                distortion = mix(distortion, distortedPattern, 0.3);
                
                // Add noise for texture
                float noise = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                distortion = mix(distortion, noise, 0.4);
                
                // Normalize to match wave pattern's range
                distortion = abs(distortion - 0.5) * 2.0;
                distortion = 1.0 - distortion;
                float original = (pattern1 + pattern2 + pattern3) / 3.0;
                distortion = mix(distortion, original, 0.5);
                
                return clamp(distortion, 0.0, 1.0);
            }
            
            // Spiral pattern
            float spiralPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                // Spiral with similar scale to wave pattern
                float angle = atan(p.y, p.x);
                float radius = length(p);
                
                float freq1 = 20.0 * detailScale;
                float freq2 = 15.0 * detailScale;
                
                float spiral = sin(radius * freq1 - angle * 10.0 + time * 0.5) * 0.5 + 0.5;
                float radial = sin(radius * freq2 + time * 0.3) * 0.5 + 0.5;
                
                // Combine and normalize similar to wave pattern
                float pattern = spiral * 0.6 + radial * 0.4;
                
                // Add noise for texture
                float noise = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                pattern = mix(pattern, noise, 0.4);
                
                // Normalize to match wave pattern's range
                pattern = abs(pattern - 0.5) * 2.0;
                pattern = 1.0 - pattern;
                
                return clamp(pattern, 0.0, 1.0);
            }
            
            // Voronoi pattern
            float voronoiPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale * 100.0; // Scale up for Voronoi cells
                vec2 i = floor(p);
                vec2 f = fract(p);
                
                float minDist = 1.0;
                for (int y = -1; y <= 1; y++) {
                    for (int x = -1; x <= 1; x++) {
                        vec2 neighbor = vec2(float(x), float(y));
                        vec2 point = vec2(
                            sin(dot(i + neighbor, vec2(12.9898, 78.233)) + time * 0.1),
                            cos(dot(i + neighbor, vec2(37.7193, 41.2345)) + time * 0.1)
                        ) * 0.5 + 0.5;
                        vec2 diff = neighbor + point - f;
                        float dist = length(diff);
                        minDist = min(minDist, dist);
                    }
                }
                
                // Normalize Voronoi distance to 0-1 range similar to wave pattern
                minDist = minDist * 2.0; // Scale up for better range
                minDist = 1.0 - minDist; // Invert so cells are bright
                
                return clamp(minDist, 0.0, 1.0);
            }
            
            // Noise clouds pattern
            float noiseCloudsPattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                // Use similar scale to wave pattern
                float n1 = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                float n2 = smoothNoise(p * 16.0 * detailScale - time * 0.15) * 0.5;
                float n3 = smoothNoise(p * 32.0 * detailScale + time * 0.1) * 0.25;
                
                // Combine noise layers
                float clouds = n1 + n2 + n3;
                
                // Normalize to match wave pattern's range
                clouds = abs(clouds - 0.5) * 2.0;
                clouds = 1.0 - clouds;
                
                return clamp(clouds, 0.0, 1.0);
            }
            
            // Wave pattern (original)
            float wavePattern(vec2 uv, float time) {
                float detailScale = max(1.0, u_iterations) / 40.0;
                vec2 p = uv * 0.01 * detailScale;
                
                float freq1 = 20.0 * detailScale;
                float freq2 = 15.0 * detailScale;
                float freq3 = 18.0 * detailScale;
                
                float pattern1 = sin(length(p) * freq1 - time * 0.5) * 0.5 + 0.5;
                float pattern2 = sin(p.x * freq2 + p.y * (freq2 * 0.8) + time * 0.3) * 0.5 + 0.5;
                float pattern3 = sin(p.y * freq3 - p.x * (freq3 * 0.55) + time * 0.4) * 0.5 + 0.5;
                
                float dist = length(p);
                float ripple = sin(dist * 30.0 * detailScale - time * 0.6) * 0.5 + 0.5;
                float noise = smoothNoise(p * 8.0 * detailScale + time * 0.2);
                
                float pattern = pattern1 * pattern2 * 0.7 + pattern3 * 0.3;
                pattern = mix(pattern, ripple, 0.3);
                pattern = mix(pattern, noise, 0.4);
                
                pattern = abs(pattern - 0.5) * 2.0;
                pattern = 1.0 - pattern;
                float original = (pattern1 + pattern2 + pattern3) / 3.0;
                pattern = mix(pattern, original, 0.5);
                
                return clamp(pattern, 0.0, 1.0);
            }
            
            // Main fractal pattern selector
            float formulaPattern(vec2 uv, float time) {
                // Use step() to prevent optimization - ensures uniform is always read
                float type = u_fractalType;
                
                if (type < 0.5) {
                    return wavePattern(uv, time);
                } else if (type < 1.5) {
                    return plasmaEnergyPattern(uv, time);
                } else if (type < 2.5) {
                    return flowFieldPattern(uv, time);
                } else if (type < 3.5) {
                    return organicGrowthPattern(uv, time);
                } else if (type < 4.5) {
                    return distortionWavesPattern(uv, time);
                } else if (type < 5.5) {
                    return spiralPattern(uv, time);
                } else if (type < 6.5) {
                    return voronoiPattern(uv, time);
                } else {
                    return noiseCloudsPattern(uv, time);
                }
            }
            
            // Procedural color palette
            vec3 palette(float t) {
                vec3 a = vec3(0.8, 0.5, 0.4);
                vec3 b = vec3(0.2, 0.4, 0.2);
                vec3 c = vec3(2.0, 1.0, 1.0);
                vec3 d = vec3(0.00, 0.25, 0.25);
                return a + b * cos(6.28318 * (c * t + d));
            }
            
            // Get color scheme hues based on base hue - returns 3 or 4 hues
            vec3 getColorSchemeHues3(float baseHue, float scheme) {
                // scheme: 0=monochromatic, 1=analogous, 2=complementary, 3=splitComplementary, 4=triadic
                vec3 hues = vec3(0.0);
                
                if (scheme < 0.5) {
                    // Monochromatic - same hue but we'll vary saturation in the mapping
                    hues = vec3(mod(baseHue - 0.02, 1.0), baseHue, mod(baseHue + 0.02, 1.0));
                } else if (scheme < 1.5) {
                    // Analogous - adjacent hues (30° apart = 0.083)
                    hues = vec3(mod(baseHue - 0.083, 1.0), baseHue, mod(baseHue + 0.083, 1.0));
                } else if (scheme < 2.5) {
                    // Complementary - base and complement, add a third between them
                    float comp = mod(baseHue + 0.5, 1.0);
                    float mid = mod(baseHue + 0.25, 1.0);
                    hues = vec3(baseHue, mid, comp);
                } else if (scheme < 3.5) {
                    // Split Complementary - base + two adjacent to complement
                    float comp = mod(baseHue + 0.5, 1.0);
                    hues = vec3(baseHue, mod(comp - 0.083, 1.0), mod(comp + 0.083, 1.0));
                } else {
                    // Triadic - three evenly spaced hues (120° apart = 0.333)
                    hues = vec3(baseHue, mod(baseHue + 0.333, 1.0), mod(baseHue + 0.667, 1.0));
                }
                
                return hues;
            }
            
            // Blend mode functions
            vec3 blendNormal(vec3 base, vec3 blend) {
                return blend;
            }
            
            vec3 blendMultiply(vec3 base, vec3 blend) {
                return base * blend;
            }
            
            vec3 blendScreen(vec3 base, vec3 blend) {
                return 1.0 - (1.0 - base) * (1.0 - blend);
            }
            
            vec3 blendOverlay(vec3 base, vec3 blend) {
                return mix(
                    2.0 * base * blend,
                    1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
                    step(0.5, base)
                );
            }
            
            vec3 blendSoftLight(vec3 base, vec3 blend) {
                vec3 result1 = 2.0 * base * blend + base * base * (1.0 - 2.0 * blend);
                vec3 result2 = sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend);
                return mix(result1, result2, step(0.5, blend));
            }
            
            vec3 blendHardLight(vec3 base, vec3 blend) {
                return blendOverlay(blend, base);
            }
            
            vec3 blendColorDodge(vec3 base, vec3 blend) {
                return base / (1.0 - blend + 0.0001);
            }
            
            vec3 blendColorBurn(vec3 base, vec3 blend) {
                return 1.0 - (1.0 - base) / (blend + 0.0001);
            }
            
            vec3 blendLinearDodge(vec3 base, vec3 blend) {
                return min(base + blend, 1.0);
            }
            
            vec3 blendLinearBurn(vec3 base, vec3 blend) {
                return max(base + blend - 1.0, 0.0);
            }
            
            vec3 blendVividLight(vec3 base, vec3 blend) {
                vec3 result1 = blendColorDodge(base, 2.0 * blend);
                vec3 result2 = blendColorBurn(base, 2.0 * (blend - 0.5));
                return mix(result1, result2, step(0.5, blend));
            }
            
            vec3 blendLinearLight(vec3 base, vec3 blend) {
                vec3 result1 = blendLinearDodge(base, 2.0 * blend);
                vec3 result2 = blendLinearBurn(base, 2.0 * (blend - 0.5));
                return mix(result1, result2, step(0.5, blend));
            }
            
            vec3 blendDifference(vec3 base, vec3 blend) {
                return abs(base - blend);
            }
            
            vec3 blendExclusion(vec3 base, vec3 blend) {
                return base + blend - 2.0 * base * blend;
            }
            
            // Blend mode selector
            vec3 applyBlendMode(vec3 base, vec3 blend, float mode) {
                vec3 blended;
                if (mode < 0.5) {
                    blended = blendNormal(base, blend);
                } else if (mode < 1.5) {
                    blended = blendMultiply(base, blend);
                } else if (mode < 2.5) {
                    blended = blendScreen(base, blend);
                } else if (mode < 3.5) {
                    blended = blendOverlay(base, blend);
                } else if (mode < 4.5) {
                    blended = blendSoftLight(base, blend);
                } else if (mode < 5.5) {
                    blended = blendHardLight(base, blend);
                } else if (mode < 6.5) {
                    blended = blendColorDodge(base, blend);
                } else if (mode < 7.5) {
                    blended = blendColorBurn(base, blend);
                } else if (mode < 8.5) {
                    blended = blendLinearDodge(base, blend);
                } else if (mode < 9.5) {
                    blended = blendLinearBurn(base, blend);
                } else if (mode < 10.5) {
                    blended = blendVividLight(base, blend);
                } else if (mode < 11.5) {
                    blended = blendLinearLight(base, blend);
                } else if (mode < 12.5) {
                    blended = blendDifference(base, blend);
                } else {
                    blended = blendExclusion(base, blend);
                }
                
                // Mix between original blend color and the blended result based on percentage
                // At 0%: use original blend (no blend mode effect)
                // At 100%: use full blended result (full blend mode effect)
                return mix(blend, blended, u_blendPercentage);
            }
            
            // Mask shape functions - return distance from edge (0 = center, 1 = edge, >1 = outside)
            float maskCircle(vec2 uv, float aspect) {
                vec2 circleUV = vec2(uv.x * aspect, uv.y);
                return length(circleUV);
            }
            
            float maskSquare(vec2 uv, float aspect) {
                vec2 squareUV = vec2(uv.x * aspect, uv.y);
                return max(abs(squareUV.x), abs(squareUV.y));
            }
            
            float maskRoundedSquare(vec2 uv, float aspect, float roundness) {
                vec2 squareUV = vec2(uv.x * aspect, uv.y);
                vec2 absUV = abs(squareUV);
                float cornerDist = length(max(absUV - (1.0 - roundness), 0.0));
                return cornerDist + min(max(absUV.x, absUV.y), 1.0 - roundness);
            }
            
            float maskDiamond(vec2 uv, float aspect) {
                vec2 diamondUV = vec2(uv.x * aspect, uv.y);
                return abs(diamondUV.x) + abs(diamondUV.y);
            }
            
            float maskHexagon(vec2 uv, float aspect) {
                vec2 hexUV = vec2(uv.x * aspect, uv.y);
                float angle = atan(hexUV.y, hexUV.x);
                float radius = length(hexUV);
                // Hexagon distance calculation
                float hexDist = cos(angle * 3.0) * radius;
                return max(abs(hexDist), abs(hexUV.y * 0.866 + hexUV.x * 0.5));
            }
            
            float maskStar(vec2 uv, float aspect) {
                vec2 starUV = vec2(uv.x * aspect, uv.y);
                float angle = atan(starUV.y, starUV.x);
                float radius = length(starUV);
                // 5-pointed star
                float starDist = cos(angle * 5.0) * radius;
                return max(starDist, radius * 0.5);
            }
            
            float maskEllipse(vec2 uv, float aspect) {
                vec2 ellipseUV = vec2(uv.x * aspect, uv.y);
                // Ellipse with different radii
                float a = 1.0; // horizontal radius
                float b = 0.7; // vertical radius
                return sqrt((ellipseUV.x / a) * (ellipseUV.x / a) + (ellipseUV.y / b) * (ellipseUV.y / b));
            }
            
            // Mask shape selector
            float getMaskDistance(vec2 uv, float aspect) {
                if (u_maskShape < 0.5) {
                    return maskCircle(uv, aspect);
                } else if (u_maskShape < 1.5) {
                    return maskSquare(uv, aspect);
                } else if (u_maskShape < 2.5) {
                    return maskRoundedSquare(uv, aspect, 0.3);
                } else if (u_maskShape < 3.5) {
                    return maskDiamond(uv, aspect);
                } else if (u_maskShape < 4.5) {
                    return maskHexagon(uv, aspect);
                } else if (u_maskShape < 5.5) {
                    return maskStar(uv, aspect);
                } else {
                    return maskEllipse(uv, aspect);
                }
            }
            
            // Get 4 color scheme hues for Square and Rectangular
            vec4 getColorSchemeHues4(float baseHue, float scheme) {
                vec4 hues = vec4(0.0);
                
                if (scheme < 5.5) {
                    // Square - four evenly spaced hues (90° apart = 0.25)
                    hues = vec4(
                        baseHue,
                        mod(baseHue + 0.25, 1.0),
                        mod(baseHue + 0.5, 1.0),
                        mod(baseHue + 0.75, 1.0)
                    );
                } else {
                    // Rectangular (Tetradic) - two complementary pairs (base, base+30°, complement, complement+30°)
                    float comp = mod(baseHue + 0.5, 1.0);
                    hues = vec4(
                        baseHue,
                        mod(baseHue + 0.083, 1.0), // 30° from base
                        comp,
                        mod(comp + 0.083, 1.0) // 30° from complement
                    );
                }
                
                return hues;
            }
            
            // Convert hue (0-1) to RGB
            vec3 hueToRGB(float h) {
                h = mod(h, 1.0);
                // Use a lower chroma value to prevent blowout when combined with brightness
                float c = 0.8; // Reduced from 1.0 to prevent white blowout
                float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
                vec3 rgb;
                
                if (h < 1.0/6.0) rgb = vec3(c, x, 0.0);
                else if (h < 2.0/6.0) rgb = vec3(x, c, 0.0);
                else if (h < 3.0/6.0) rgb = vec3(0.0, c, x);
                else if (h < 4.0/6.0) rgb = vec3(0.0, x, c);
                else if (h < 5.0/6.0) rgb = vec3(x, 0.0, c);
                else rgb = vec3(c, 0.0, x);
                
                // Normalize to prevent values > 1.0
                return clamp(rgb, 0.0, 1.0);
            }
            
            // Rotate hue in RGB space
            vec3 rotateHue(vec3 rgb, float hueShift) {
                // Convert to HSV
                float maxVal = max(max(rgb.r, rgb.g), rgb.b);
                float minVal = min(min(rgb.r, rgb.g), rgb.b);
                float delta = maxVal - minVal;
                
                float hue = 0.0;
                if (delta > 0.001) {
                    if (maxVal == rgb.r) {
                        hue = mod((rgb.g - rgb.b) / delta + (rgb.g < rgb.b ? 6.0 : 0.0), 6.0) / 6.0;
                    } else if (maxVal == rgb.g) {
                        hue = ((rgb.b - rgb.r) / delta + 2.0) / 6.0;
                    } else {
                        hue = ((rgb.r - rgb.g) / delta + 4.0) / 6.0;
                    }
                }
                
                // Apply hue shift
                hue = mod(hue + hueShift, 1.0);
                
                // Convert back to RGB
                float c = delta;
                float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));
                float m = minVal;
                
                vec3 rgbOut;
                if (hue < 1.0/6.0) rgbOut = vec3(c, x, 0.0);
                else if (hue < 2.0/6.0) rgbOut = vec3(x, c, 0.0);
                else if (hue < 3.0/6.0) rgbOut = vec3(0.0, c, x);
                else if (hue < 4.0/6.0) rgbOut = vec3(0.0, x, c);
                else if (hue < 5.0/6.0) rgbOut = vec3(x, 0.0, c);
                else rgbOut = vec3(c, 0.0, x);
                
                return rgbOut + vec3(m);
            }
            
            void main() {
                // Start with normalized UV coordinates (0-1 range)
                vec2 baseUV = v_uv;
                vec2 uv = v_uv - 0.5;  // Now -0.5 to 0.5
                
                // Scale to -1 to 1 range for proper unit circle
                uv *= 2.0;  // Now -1.0 to 1.0
                
                // Calculate aspect ratio
                float aspect = u_resolution.x / u_resolution.y;
                
                // Get mask distance based on selected mask shape
                float screenDist = getMaskDistance(uv, aspect);
                
                // Hard clip - nothing outside the mask
                if (screenDist >= 1.0) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }
                
                // Apply aspect correction for 3D calculations
                uv.x *= aspect;
                
                // Normalize to unit circle (for stage shape calculations)
                float dist = length(uv);
                if (dist > 0.999) {
                    dist = 0.999;
                    uv = normalize(uv) * dist;
                }
                
                // Scale for zoom
                uv *= u_zoom;
                dist = length(uv);
                if (dist > 0.999) {
                    dist = 0.999;
                    uv = normalize(uv) * dist;
                }
                
                // Convert UV to stage shape position (view direction)
                vec3 spherePos = toStageShape(uv, u_displayMode);
                
                // Calculate distance from center
                float distFromCenter = length(spherePos);
                
                // Sphere parameters - smooth glass snowglobe
                float sphereRadius = 0.90;
                
                // Get fluid distortion
                vec2 fluidDistortion = fluidFlow(baseUV, u_time);
                
                // Calculate inside depth
                float insideDepth = clamp(distFromCenter / sphereRadius, 0.0, 1.0); // 0 = center, 1 = surface
                
                // insidePos: position for lighting/visual effects
                vec3 insidePos = spherePos * (0.1 + insideDepth * 0.8);
                
                // For pattern sampling: use sphere position
                // Camera rotation (applied in sphereToUV) moves the grid pole
                // Grid rotation (applied in sphereToUV) rotates the pattern on the sphere
                vec3 patternPos = spherePos * (0.1 + insideDepth * 0.8);
                
                // Convert inside position to UV for fluid sampling
                // shapeToUV applies camera rotation (moves pole) then grid rotation (rotates pattern)
                vec2 insideUV = shapeToUV(patternPos);
                
                // Sample fractal at INSIDE position - use fixed scale for consistency across devices
                vec2 fractalUV = insideUV;
                // Use fixed pattern scale instead of resolution-dependent scaling
                fractalUV = insideUV * u_patternScale;
                float insideFractal = formulaPattern(fractalUV, u_time);
                
                // Fractal drives fluid flow
                vec2 insideFractalFlow = vec2(
                    sin(insideFractal * 6.28318 + u_time * u_flowSpeed * 0.5),
                    cos(insideFractal * 6.28318 - u_time * u_flowSpeed * 0.3)
                ) * insideFractal * 0.3;
                
                // Combine with fluid flow - make fluid intensity more effective
                vec2 insideCombinedFlow = fluidDistortion * (0.3 + u_fluidIntensity * 0.4) + insideFractalFlow * (u_fluidIntensity * 1.5);
                vec2 insideFluidUV = insideUV + insideCombinedFlow * (0.2 + u_fluidIntensity * 0.4);
                vec2 fractalFluidUV = insideFluidUV;
                // Use fixed pattern scale for consistency across devices
                fractalFluidUV = insideFluidUV * u_patternScale;
                float insideFluidFractal = formulaPattern(fractalFluidUV, u_time);
                
                // Fluid density - make intensity more effective, ensure minimum visibility
                float insideFluidDensity = insideFluidFractal * (0.3 + u_fluidIntensity * 0.7) + 0.15;
                
                // Map inside fractal to color
                float insidePatternValue = insideFluidFractal;
                insidePatternValue = (insidePatternValue - 0.5) * u_colorRange + 0.5;
                insidePatternValue = clamp(insidePatternValue, 0.0, 1.0);
                
                vec3 fluidCol;
                if (u_colorScheme < 0.5) {
                    float sat = insidePatternValue * 0.8 + 0.2;
                    float bright = insidePatternValue * 0.9 + 0.1;
                    fluidCol = hueToRGB(u_hue) * bright;
                    fluidCol = mix(vec3(dot(fluidCol, vec3(0.299, 0.587, 0.114))), fluidCol, sat);
                } else if (u_colorScheme < 4.5) {
                    vec3 schemeHues = getColorSchemeHues3(u_hue, u_colorScheme);
                    vec3 color1 = hueToRGB(schemeHues.x);
                    vec3 color2 = hueToRGB(schemeHues.y);
                    vec3 color3 = hueToRGB(schemeHues.z);
                    float segment = insidePatternValue * 3.0;
                    if (segment < 1.0) {
                        vec3 mixed = mix(color1, color2, segment);
                        fluidCol = applyBlendMode(color1, mixed, u_blendMode);
                    } else if (segment < 2.0) {
                        vec3 mixed = mix(color2, color3, segment - 1.0);
                        fluidCol = applyBlendMode(color2, mixed, u_blendMode);
                    } else {
                        vec3 mixed = mix(color3, color1, segment - 2.0);
                        fluidCol = applyBlendMode(color3, mixed, u_blendMode);
                    }
                } else {
                    vec4 schemeHues = getColorSchemeHues4(u_hue, u_colorScheme);
                    vec3 color1 = hueToRGB(schemeHues.x);
                    vec3 color2 = hueToRGB(schemeHues.y);
                    vec3 color3 = hueToRGB(schemeHues.z);
                    vec3 color4 = hueToRGB(schemeHues.w);
                    float segment = insidePatternValue * 4.0;
                    if (segment < 1.0) {
                        vec3 mixed = mix(color1, color2, segment);
                        fluidCol = applyBlendMode(color1, mixed, u_blendMode);
                    } else if (segment < 2.0) {
                        vec3 mixed = mix(color2, color3, segment - 1.0);
                        fluidCol = applyBlendMode(color2, mixed, u_blendMode);
                    } else if (segment < 3.0) {
                        vec3 mixed = mix(color3, color4, segment - 2.0);
                        fluidCol = applyBlendMode(color3, mixed, u_blendMode);
                    } else {
                        vec3 mixed = mix(color4, color1, segment - 3.0);
                        fluidCol = applyBlendMode(color4, mixed, u_blendMode);
                    }
                }
                
                // Bump mapping using fractal pattern
                // Sample fractal at nearby points to calculate gradient (normal perturbation)
                // Use pattern-relative epsilon for consistent bump detail
                float bumpEpsilon = 1.0; // Offset in pattern space (larger = smoother bumps)
                float bumpHeight = insideFluidFractal;
                float bumpX = formulaPattern(fractalFluidUV + vec2(bumpEpsilon, 0.0), u_time);
                float bumpY = formulaPattern(fractalFluidUV + vec2(0.0, bumpEpsilon), u_time);
                
                // Calculate gradient (change in bump height)
                // Normalize by epsilon to get proper gradient magnitude
                float dx = (bumpX - bumpHeight) / bumpEpsilon;
                float dy = (bumpY - bumpHeight) / bumpEpsilon;
                
                // Surface normal (initially pointing outward from sphere)
                vec3 surfaceNormal = normalize(insidePos);
                
                // Perturb normal using gradient (bump mapping)
                // Create tangent basis from surface normal
                vec3 tangent = normalize(cross(surfaceNormal, vec3(0.0, 1.0, 0.0)));
                if (length(tangent) < 0.1) {
                    // Fallback if normal is parallel to Y axis
                    tangent = normalize(cross(surfaceNormal, vec3(1.0, 0.0, 0.0)));
                }
                vec3 bitangent = normalize(cross(surfaceNormal, tangent));
                
                // Perturb normal using gradient - scale by bump strength
                // Make the effect much more pronounced - increase multiplier significantly
                vec3 normalOffset = (tangent * dx + bitangent * dy) * u_bumpStrength * 5.0;
                vec3 bumpedNormal = normalize(surfaceNormal + normalOffset);
                
                // Render smooth fluid with internal light source
                // Brightness is a percentage (0-100%) controlling internal light intensity
                float brightnessPercent = u_bright / 100.0; // 0.0 to 1.0
                
                // Internal light source position (at center of sphere)
                vec3 lightPos = vec3(0.0, 0.0, 0.0);
                
                // Calculate light direction
                vec3 lightDir = normalize(lightPos - insidePos);
                
                // Calculate distance from current position to light source
                float distToLight = length(insidePos - lightPos);
                
                // Light falloff: closer to light = brighter, further = dimmer
                // Use inverse square law with some tweaking for artistic effect
                float maxDist = sphereRadius * 0.9; // Maximum distance in sphere
                float normalizedDist = clamp(distToLight / maxDist, 0.0, 1.0);
                
                // Diffuse lighting using bumped normal
                float NdotL_bumped = max(dot(bumpedNormal, lightDir), 0.0);
                
                // Also calculate with original normal for comparison
                float NdotL_original = max(dot(surfaceNormal, lightDir), 0.0);
                
                // Light intensity falls off with distance (closer = brighter)
                // Brightness controls the overall light intensity
                float lightIntensity = (1.0 - normalizedDist * 0.7) * brightnessPercent;
                lightIntensity = pow(lightIntensity, 1.5); // Softer falloff
                
                // Base fluid color illuminated by internal light
                // The light illuminates the fluid from within
                vec3 baseColor = fluidCol * insideFluidDensity;
                
                // Apply internal lighting with bump mapping: fluid is illuminated from the center
                // Mix between original and bumped lighting based on bump strength
                // Make the difference more dramatic - use full range
                float NdotL_diff = NdotL_bumped - NdotL_original;
                float finalNdotL = NdotL_original + NdotL_diff * u_bumpStrength;
                
                // Enhance the contrast - bump mapping should create more variation
                // Apply stronger contrast when bump strength is high
                finalNdotL = mix(finalNdotL, pow(finalNdotL, 0.6), u_bumpStrength * 0.7);
                
                float finalIntensity = lightIntensity * (0.05 + finalNdotL * 0.95);
                fluidCol = baseColor * finalIntensity * 20.0;
                
                // Add specular highlight for more pronounced bump effect
                vec3 viewDir = normalize(-insidePos);
                vec3 reflectDir = reflect(-lightDir, bumpedNormal);
                float specular = pow(max(dot(viewDir, reflectDir), 0.0), 12.0) * u_bumpStrength;
                fluidCol += vec3(1.0, 0.95, 0.9) * specular * lightIntensity * brightnessPercent * 8.0;
                
                // Add rim lighting that responds to bump mapping
                float rim = pow(1.0 - max(dot(viewDir, bumpedNormal), 0.0), 2.0) * u_bumpStrength * 0.8;
                fluidCol += baseColor * rim * lightIntensity;
                
                // Add some emission for glow effect in brighter areas
                float emission = pow(insideFluidDensity, 0.8) * lightIntensity * brightnessPercent * 3.0;
                fluidCol += fluidCol * emission;
                
                // Add smooth flow visualization (lower frequency for smoothness)
                // Use the same color scheme as the main fluid
                float flowStrength = smoothstep(0.0, 1.5, length(insideCombinedFlow));
                float flowPattern = sin(insideCombinedFlow.x * 5.0 + insideCombinedFlow.y * 4.0 + u_time * u_flowSpeed * 2.0) * 0.5 + 0.5;
                flowPattern = (flowPattern - 0.5) * u_colorRange + 0.5;
                flowPattern = clamp(flowPattern, 0.0, 1.0);
                
                vec3 flowColor;
                if (u_colorScheme < 0.5) {
                    float sat = flowPattern * 0.8 + 0.2;
                    float bright = flowPattern * 0.9 + 0.1;
                    flowColor = hueToRGB(u_hue) * bright;
                    flowColor = mix(vec3(dot(flowColor, vec3(0.299, 0.587, 0.114))), flowColor, sat);
                } else if (u_colorScheme < 4.5) {
                    vec3 schemeHues = getColorSchemeHues3(u_hue, u_colorScheme);
                    vec3 color1 = hueToRGB(schemeHues.x);
                    vec3 color2 = hueToRGB(schemeHues.y);
                    vec3 color3 = hueToRGB(schemeHues.z);
                    float segment = flowPattern * 3.0;
                    if (segment < 1.0) {
                        vec3 mixed = mix(color1, color2, segment);
                        flowColor = applyBlendMode(color1, mixed, u_blendMode);
                    } else if (segment < 2.0) {
                        vec3 mixed = mix(color2, color3, segment - 1.0);
                        flowColor = applyBlendMode(color2, mixed, u_blendMode);
                    } else {
                        vec3 mixed = mix(color3, color1, segment - 2.0);
                        flowColor = applyBlendMode(color3, mixed, u_blendMode);
                    }
                } else {
                    vec4 schemeHues = getColorSchemeHues4(u_hue, u_colorScheme);
                    vec3 color1 = hueToRGB(schemeHues.x);
                    vec3 color2 = hueToRGB(schemeHues.y);
                    vec3 color3 = hueToRGB(schemeHues.z);
                    vec3 color4 = hueToRGB(schemeHues.w);
                    float segment = flowPattern * 4.0;
                    if (segment < 1.0) {
                        vec3 mixed = mix(color1, color2, segment);
                        flowColor = applyBlendMode(color1, mixed, u_blendMode);
                    } else if (segment < 2.0) {
                        vec3 mixed = mix(color2, color3, segment - 1.0);
                        flowColor = applyBlendMode(color2, mixed, u_blendMode);
                    } else if (segment < 3.0) {
                        vec3 mixed = mix(color3, color4, segment - 2.0);
                        flowColor = applyBlendMode(color3, mixed, u_blendMode);
                    } else {
                        vec3 mixed = mix(color4, color1, segment - 3.0);
                        flowColor = applyBlendMode(color4, mixed, u_blendMode);
                    }
                }
                
                // Apply blend mode when combining flowColor with fluidCol
                vec3 blendedFlow = applyBlendMode(fluidCol, flowColor, u_blendMode);
                fluidCol = mix(fluidCol, blendedFlow, flowStrength * insideFluidDensity * 0.4);
                
                // Depth-based variation
                float depthFactor = insideDepth;
                fluidCol *= (0.5 + depthFactor * 0.5);
                
                // Clamp final color to prevent blowout
                fluidCol = clamp(fluidCol, 0.0, 1.0);
                
                // Add subtle smooth motion
                fluidCol += sin(insideFluidFractal * 6.0 + u_time * u_flowSpeed) * 0.03;
                
                // Smooth fade at edges - go all the way to the edge
                // Fade only in the last 10% near the edge for smooth transition
                float edgeFade = 1.0 - smoothstep(0.9, 1.0, screenDist);
                
                // Render fluid inside with edge fade
                vec3 col = fluidCol * edgeFade;
                
                // Smooth tone mapping for glass snowglobe effect
                col = col / (1.0 + col * 0.1);
                col = pow(max(col, vec3(0.0)), vec3(0.9));
                col *= 2.0;
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function compileShader(src, type) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                const err = gl.getShaderInfoLog(s);
                alert('Shader error: ' + err);
                console.error('Shader source:', src);
                return null;
            }
            return s;
        }
        
        function createProgram(vsSrc, fsSrc) {
            const vsh = compileShader(vsSrc, gl.VERTEX_SHADER);
            const fsh = compileShader(fsSrc, gl.FRAGMENT_SHADER);
            if (!vsh || !fsh) return null;
            const prog = gl.createProgram();
            gl.attachShader(prog, vsh);
            gl.attachShader(prog, fsh);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(prog));
                return null;
            }
            return prog;
        }
        
        // Compile Navier-Stokes shader programs
        const advectionProg = createProgram(vs, advectionFS);
        const diffusionProg = createProgram(vs, diffusionFS);
        const divergenceProg = createProgram(vs, divergenceFS);
        const pressureProg = createProgram(vs, pressureFS);
        const gradientSubtractProg = createProgram(vs, gradientSubtractFS);
        const addForceProg = createProgram(vs, addForceFS);
        
        // Helper function to render to texture
        function renderToTexture(program, uniforms, targetFB, width, height) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, targetFB);
            gl.viewport(0, 0, width, height);
            gl.useProgram(program);
            
            let texUnit = 0;
            
            // Set uniforms
            for (const [name, value] of Object.entries(uniforms)) {
                const loc = gl.getUniformLocation(program, name);
                if (loc === null) continue;
                
                if (typeof value === 'number') {
                    gl.uniform1f(loc, value);
                } else if (value instanceof Array && value.length === 2) {
                    gl.uniform2f(loc, value[0], value[1]);
                } else if (value instanceof WebGLTexture) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    gl.bindTexture(gl.TEXTURE_2D, value);
                    gl.uniform1i(loc, texUnit);
                    texUnit++;
                }
            }
            
            // Draw full-screen quad
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            const posLoc = gl.getAttribLocation(program, 'a_pos');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        // Navier-Stokes simulation step
        function simulateFluid(dt) {
            if (!advectionProg || !diffusionProg || !divergenceProg || !pressureProg || !gradientSubtractProg) {
                console.warn('Navier-Stokes shaders not compiled, skipping simulation');
                return;
            }
            
            const simRes = [SIM_WIDTH, SIM_HEIGHT];
            // Base dissipation (energy loss over time)
            const baseDissipation = 0.95;
            const dissipation = baseDissipation; // Keep constant
            const dyeDissipation = 0.97; // Keep constant
            const pressureIterations = 20; // Number of Jacobi iterations
            
            // Get correct framebuffers
            const velocityFBWrite = velocityWrite === velocityTexA ? velocityFBA : velocityFBB;
            const pressureFBWrite = pressureWrite === pressureTexA ? pressureFBA : pressureFBB;
            const dyeFBWrite = dyeWrite === dyeTexA ? dyeFBA : dyeFBB;
            
            // Step 1: Advect velocity
            renderToTexture(advectionProg, {
                'u_velocity': velocityRead,
                'u_source': velocityRead,
                'u_resolution': simRes,
                'u_dt': dt * params.flowSpeed, // Flow speed affects time step
                'u_dissipation': dissipation
            }, velocityFBWrite, SIM_WIDTH, SIM_HEIGHT);
            swapVelocity();
            
            // Step 1.5: Apply viscosity diffusion (this is what viscosity actually does!)
            if (params.viscosity > 0.01) {
                // Run diffusion multiple times for stronger effect
                const diffusionIterations = Math.floor(params.viscosity * 4) + 1;
                for (let i = 0; i < diffusionIterations; i++) {
                    renderToTexture(diffusionProg, {
                        'u_velocity': velocityRead,
                        'u_resolution': simRes,
                        'u_viscosity': params.viscosity,
                        'u_dt': dt
                    }, velocityFBWrite, SIM_WIDTH, SIM_HEIGHT);
                    swapVelocity();
                }
            }
            
            // Add forces based on fluid intensity (creates swirling motion)
            if (params.fluidIntensity > 0.1 && addForceProg) {
                // Add multiple force points for swirling effect
                const numForces = 3;
                for (let i = 0; i < numForces; i++) {
                    const angle = (time * 0.5 + i * 2.0 * Math.PI / numForces) * params.flowSpeed;
                    const radius = 0.3;
                    const forcePos = [
                        SIM_WIDTH * 0.5 + Math.cos(angle) * radius * SIM_WIDTH,
                        SIM_HEIGHT * 0.5 + Math.sin(angle) * radius * SIM_HEIGHT
                    ];
                    const force = [
                        Math.cos(angle + Math.PI / 2) * params.fluidIntensity * 0.15,
                        Math.sin(angle + Math.PI / 2) * params.fluidIntensity * 0.15
                    ];
                    
                    renderToTexture(addForceProg, {
                        'u_velocity': velocityRead,
                        'u_force': force,
                        'u_forcePos': forcePos,
                        'u_resolution': simRes,
                        'u_forceRadius': 40.0
                    }, velocityFBWrite, SIM_WIDTH, SIM_HEIGHT);
                    swapVelocity();
                }
            }
            
            // Step 2: Compute divergence
            renderToTexture(divergenceProg, {
                'u_velocity': velocityRead,
                'u_resolution': simRes
            }, divergenceFB, SIM_WIDTH, SIM_HEIGHT);
            
            // Step 3: Solve pressure (Jacobi iterations)
            // Clear pressure
            gl.bindFramebuffer(gl.FRAMEBUFFER, pressureFBWrite);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            swapPressure();
            
            for (let i = 0; i < pressureIterations; i++) {
                const currentPressureFBWrite = pressureWrite === pressureTexA ? pressureFBA : pressureFBB;
                renderToTexture(pressureProg, {
                    'u_pressure': pressureRead,
                    'u_divergence': divergenceTex,
                    'u_resolution': simRes
                }, currentPressureFBWrite, SIM_WIDTH, SIM_HEIGHT);
                swapPressure();
            }
            
            // Step 4: Subtract pressure gradient from velocity
            const currentVelocityFBWrite = velocityWrite === velocityTexA ? velocityFBA : velocityFBB;
            renderToTexture(gradientSubtractProg, {
                'u_velocity': velocityRead,
                'u_pressure': pressureRead,
                'u_resolution': simRes
            }, currentVelocityFBWrite, SIM_WIDTH, SIM_HEIGHT);
            swapVelocity();
            
            // Step 5: Advect dye through velocity field
            renderToTexture(advectionProg, {
                'u_velocity': velocityRead,
                'u_source': dyeRead,
                'u_resolution': simRes,
                'u_dt': dt * params.flowSpeed, // Flow speed affects dye advection too
                'u_dissipation': dyeDissipation
            }, dyeFBWrite, SIM_WIDTH, SIM_HEIGHT);
            swapDye();
        }

        const vsh = compileShader(vs, gl.VERTEX_SHADER);
        const fsh = compileShader(fs, gl.FRAGMENT_SHADER);
        const prog = gl.createProgram();
        gl.attachShader(prog, vsh);
        gl.attachShader(prog, fsh);
        gl.linkProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

        const locs = {
            pos: gl.getAttribLocation(prog, 'a_pos'),
            time: gl.getUniformLocation(prog, 'u_time'),
            zoom: gl.getUniformLocation(prog, 'u_zoom'),
            curvature: gl.getUniformLocation(prog, 'u_curvature'),
            iterations: gl.getUniformLocation(prog, 'u_iterations'),
            bright: gl.getUniformLocation(prog, 'u_bright'),
            displayMode: gl.getUniformLocation(prog, 'u_displayMode'),
            hue: gl.getUniformLocation(prog, 'u_hue'),
            rotation3D: gl.getUniformLocation(prog, 'u_rotation3D'),
            cameraRotation: gl.getUniformLocation(prog, 'u_cameraRotation'),
            res: gl.getUniformLocation(prog, 'u_resolution'),
            patternScale: gl.getUniformLocation(prog, 'u_patternScale'),
            bumpStrength: gl.getUniformLocation(prog, 'u_bumpStrength'),
            colorScheme: gl.getUniformLocation(prog, 'u_colorScheme'),
            colorRange: gl.getUniformLocation(prog, 'u_colorRange'),
            blendMode: gl.getUniformLocation(prog, 'u_blendMode'),
            blendPercentage: gl.getUniformLocation(prog, 'u_blendPercentage'),
            fluidIntensity: gl.getUniformLocation(prog, 'u_fluidIntensity'),
            flowSpeed: gl.getUniformLocation(prog, 'u_flowSpeed'),
            viscosity: gl.getUniformLocation(prog, 'u_viscosity'),
            showGrid: gl.getUniformLocation(prog, 'u_showGrid'),
            velocityField: gl.getUniformLocation(prog, 'u_velocityField'),
            dyeField: gl.getUniformLocation(prog, 'u_dyeField'),
            simResolution: gl.getUniformLocation(prog, 'u_simResolution'),
            fractalType: gl.getUniformLocation(prog, 'u_fractalType'),
            stageShape: gl.getUniformLocation(prog, 'u_stageShape'),
            maskShape: gl.getUniformLocation(prog, 'u_maskShape')
        };
        
        // Debug: Check if uniforms were found
        if (locs.cameraRotation === null) {
            console.error('Camera rotation uniform not found! Check shader.');
        } else {
            console.log('Camera rotation uniform found at location:', locs.cameraRotation);
        }
        if (locs.colorScheme === null) {
            console.error('Color scheme uniform not found! Check shader.');
        }
        if (locs.colorRange === null) {
            console.error('Color range uniform not found! Check shader.');
        }
        if (locs.fractalType === null) {
            console.error('Fractal type uniform not found! Check shader.');
        } else {
            console.log('Fractal type uniform found at location:', locs.fractalType);
        }

        // 3D rotation using Euler angles
        function rotationMatrix3D(pitch, yaw, roll) {
            const cp = Math.cos(pitch);
            const sp = Math.sin(pitch);
            const cy = Math.cos(yaw);
            const sy = Math.sin(yaw);
            const cr = Math.cos(roll);
            const sr = Math.sin(roll);
            
            return new Float32Array([
                cy * cr, -cy * sr * cp + sy * sp, cy * sr * sp + sy * cp,
                sr, cr * cp, -cr * sp,
                -sy * cr, sy * sr * cp + cy * sp, -sy * sr * sp + cy * cp
            ]);
        }

        let time = 0;
        let rotation = { pitch: 0, yaw: 0, roll: 0 }; // Grid rotation (current behavior)
        let cameraRotation = { pitch: 0, yaw: 0, roll: 0 }; // Perspective/camera rotation
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        const debug = document.getElementById('debug');
        let showGrid = true;
        let colorScheme = 0; // 0=monochromatic, 1=analogous, 2=complementary, 3=splitComplementary, 4=triadic, 5=square, 6=rectangular
        
        // Color scheme mapping
        const colorSchemes = {
            monochromatic: 0,
            analogous: 1,
            complementary: 2,
            splitComplementary: 3,
            triadic: 4,
            square: 5,
            rectangular: 6
        };
        
        let params = {
            timeSpeed: 0.3,
            zoom: 0.8,
            curvature: 1.0,
            iterations: 40,
            bright: 50,  // New range: 0-100%, default 50% (moderate glow)
            bumpStrength: 0.3,  // Bump mapping strength (0-1)
            stageShape: 0.0,  // Default: Sphere
            maskShape: 0.0,   // Default: Circle
            displayMode: 0,
            hue: 0.0,
            colorRange: 1.0,
            blendMode: 0.0,  // Default: Normal blend mode
            blendPercentage: 100.0,  // Default: 100% (full blend effect)
            fluidIntensity: 1.0,  // New range: 0-3, default 1.0 (more effective)
            flowSpeed: 1.0,
            viscosity: 0.3
        };

        ['timeSpeed', 'zoom', 'curvature', 'iterations', 'bright', 'hue'].forEach(id => {
            const el = document.getElementById(id);
            const val = document.getElementById(id + 'Val');
            el.addEventListener('input', (e) => {
                params[id] = parseFloat(e.target.value);
                if (id === 'bright') {
                    val.textContent = params[id].toFixed(0) + '%';
                } else {
                    val.textContent = params[id].toFixed(id === 'iterations' ? 0 : 2);
                }
            });
        });
        
        const bumpStrengthEl = document.getElementById('bumpStrength');
        const bumpStrengthVal = document.getElementById('bumpStrengthVal');
        bumpStrengthEl.addEventListener('input', (e) => {
            params.bumpStrength = parseFloat(e.target.value);
            bumpStrengthVal.textContent = params.bumpStrength.toFixed(2);
            console.log('Bump strength changed to:', params.bumpStrength);
        });

        const stageShapeEl = document.getElementById('stageShape');
        stageShapeEl.addEventListener('change', (e) => {
            params.stageShape = parseFloat(e.target.value);
        });
        
        const maskShapeEl = document.getElementById('maskShape');
        maskShapeEl.addEventListener('change', (e) => {
            params.maskShape = parseFloat(e.target.value);
        });
        
        const displayModeEl = document.getElementById('displayMode');
        displayModeEl.addEventListener('change', (e) => {
            params.displayMode = parseFloat(e.target.value);
        });
        
        const colorSchemeEl = document.getElementById('colorScheme');
        colorSchemeEl.addEventListener('change', (e) => {
            const scheme = e.target.value;
            colorScheme = colorSchemes[scheme];
        });
        
        // Mobile controls toggle
        const controlsToggle = document.getElementById('controlsToggle');
        const controlsPanel = document.getElementById('controls');
        
        if (controlsToggle) {
            controlsToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                controlsPanel.classList.toggle('open');
            });
            
            // Close controls when clicking outside on mobile
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 767) {
                    if (!controlsPanel.contains(e.target) && !controlsToggle.contains(e.target)) {
                        controlsPanel.classList.remove('open');
                    }
                }
            });
        }
        
        // Collapsible sections
        const sections = document.querySelectorAll('.control-section');
        sections.forEach(section => {
            const title = section.querySelector('.control-section-title');
            title.addEventListener('click', () => {
                section.classList.toggle('collapsed');
                // Save state to localStorage
                const sectionName = title.textContent.trim();
                const isCollapsed = section.classList.contains('collapsed');
                localStorage.setItem(`section_${sectionName}`, isCollapsed ? 'collapsed' : 'expanded');
            });
            
            // Restore state from localStorage
            const sectionName = title.textContent.trim();
            const savedState = localStorage.getItem(`section_${sectionName}`);
            if (savedState === 'collapsed') {
                section.classList.add('collapsed');
            }
        });
        
        const hideGridEl = document.getElementById('hideGridBtn');
        hideGridEl.addEventListener('click', () => {
            showGrid = !showGrid;
            debug.classList.toggle('hidden', !showGrid);
            hideGridEl.textContent = showGrid ? 'Hide Grid' : 'Show Grid';
        });
        
        // Fractal type selector
        const fractalTypeEl = document.getElementById('fractalType');
        let fractalType = 0.0; // Initialize as float
        if (fractalTypeEl) {
            fractalTypeEl.addEventListener('change', (e) => {
                fractalType = parseFloat(e.target.value);
                console.log('Fractal type changed to:', fractalType, 'uniform location:', locs.fractalType);
            });
        } else {
            console.error('Fractal type element not found!');
        }
        
        // Handle controls with custom value display IDs
        const fluidEl = document.getElementById('fluid');
        const flowSpeedEl = document.getElementById('flowSpeed');
        const viscosityEl = document.getElementById('viscosity');
        const colorRangeEl = document.getElementById('colorRange');
        
        fluidEl.addEventListener('input', (e) => {
            params.fluidIntensity = parseFloat(e.target.value);
            document.getElementById('fluidVal').textContent = params.fluidIntensity.toFixed(1);
        });
        
        flowSpeedEl.addEventListener('input', (e) => {
            params.flowSpeed = parseFloat(e.target.value);
            document.getElementById('flowVal').textContent = params.flowSpeed.toFixed(1);
        });
        
        viscosityEl.addEventListener('input', (e) => {
            params.viscosity = parseFloat(e.target.value);
            document.getElementById('viscVal').textContent = params.viscosity.toFixed(2);
        });
        
        colorRangeEl.addEventListener('input', (e) => {
            params.colorRange = parseFloat(e.target.value);
            document.getElementById('colorRangeVal').textContent = params.colorRange.toFixed(1);
        });
        
        const blendModeEl = document.getElementById('blendMode');
        blendModeEl.addEventListener('change', (e) => {
            params.blendMode = parseFloat(e.target.value);
        });
        
        const blendPercentageEl = document.getElementById('blendPercentage');
        const blendPercentageVal = document.getElementById('blendPercentageVal');
        blendPercentageEl.addEventListener('input', (e) => {
            params.blendPercentage = parseFloat(e.target.value);
            blendPercentageVal.textContent = params.blendPercentage.toFixed(0) + '%';
        });

        // Mouse/Touch rotation - rotate grid pattern
        let touchId = null;
        
        function getPointerPos(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }
        
        function handleStart(e) {
            e.preventDefault();
            const pos = getPointerPos(e);
            isDragging = true;
            lastMouse.x = pos.x;
            lastMouse.y = pos.y;
            if (e.touches) {
                touchId = e.touches[0].identifier;
            }
        }
        
        function handleMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            let touch = null;
            if (e.touches) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        touch = e.touches[i];
                        break;
                    }
                }
                if (!touch && e.touches.length > 0) {
                    touch = e.touches[0];
                    touchId = touch.identifier;
                }
            }
            
            const pos = touch ? { x: touch.clientX, y: touch.clientY } : getPointerPos(e);
            const dx = (pos.x - lastMouse.x) / canvas.width;
            const dy = (pos.y - lastMouse.y) / canvas.height;
            
            // Rotate grid mapping
            rotation.yaw += dx * 3.0;
            rotation.pitch += dy * 3.0;
            
            // Clamp pitch to avoid gimbal lock
            rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
            
            lastMouse.x = pos.x;
            lastMouse.y = pos.y;
        }
        
        function handleEnd(e) {
            if (e.touches && e.touches.length === 0) {
                isDragging = false;
                touchId = null;
            } else if (!e.touches) {
                isDragging = false;
                touchId = null;
            }
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);
        
        // Touch events
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        // Initialize fluid simulation textures with some initial state
        function initializeFluid() {
            // Initialize velocity with some initial swirling motion
            gl.bindFramebuffer(gl.FRAMEBUFFER, velocityFBA);
            gl.viewport(0, 0, SIM_WIDTH, SIM_HEIGHT);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Add initial forces to get fluid moving
            if (addForceProg) {
                const simRes = [SIM_WIDTH, SIM_HEIGHT];
                // Add a few initial swirls
                for (let i = 0; i < 4; i++) {
                    const angle = i * Math.PI / 2;
                    const forcePos = [
                        SIM_WIDTH * 0.5 + Math.cos(angle) * SIM_WIDTH * 0.2,
                        SIM_HEIGHT * 0.5 + Math.sin(angle) * SIM_HEIGHT * 0.2
                    ];
                    const force = [
                        Math.cos(angle + Math.PI / 2) * 0.05,
                        Math.sin(angle + Math.PI / 2) * 0.05
                    ];
                    
                    renderToTexture(addForceProg, {
                        'u_velocity': velocityRead,
                        'u_force': force,
                        'u_forcePos': forcePos,
                        'u_resolution': simRes,
                        'u_forceRadius': 40.0
                    }, velocityFBA, SIM_WIDTH, SIM_HEIGHT);
                }
            }
            
            // Initialize dye with some pattern
            gl.bindFramebuffer(gl.FRAMEBUFFER, dyeFBA);
            gl.viewport(0, 0, SIM_WIDTH, SIM_HEIGHT);
            gl.clearColor(0.5, 0.5, 0.5, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        
        // Initialize on startup
        initializeFluid();
        
        function render() {
            time += 0.016 * params.timeSpeed;
            
            // Run Navier-Stokes simulation
            const dt = 0.016 * params.timeSpeed;
            simulateFluid(dt);
            
            // Switch back to main framebuffer for final rendering
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.useProgram(prog);
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.enableVertexAttribArray(locs.pos);
            gl.vertexAttribPointer(locs.pos, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(locs.time, time);
            gl.uniform1f(locs.zoom, params.zoom);
            gl.uniform1f(locs.curvature, params.curvature);
            gl.uniform1f(locs.iterations, params.iterations);
            gl.uniform1f(locs.bright, params.bright);
            if (locs.bumpStrength !== null) {
                gl.uniform1f(locs.bumpStrength, params.bumpStrength);
            } else {
                console.warn('Bump strength uniform not found!');
            }
            gl.uniform1f(locs.displayMode, params.displayMode);
            gl.uniform1f(locs.hue, params.hue);
            if (locs.colorScheme !== null) gl.uniform1f(locs.colorScheme, colorScheme);
            if (locs.colorRange !== null) gl.uniform1f(locs.colorRange, params.colorRange);
            if (locs.blendMode !== null) gl.uniform1f(locs.blendMode, params.blendMode);
            if (locs.blendPercentage !== null) gl.uniform1f(locs.blendPercentage, params.blendPercentage / 100.0);
            gl.uniform1f(locs.fluidIntensity, params.fluidIntensity);
            gl.uniform1f(locs.flowSpeed, params.flowSpeed);
            gl.uniform1f(locs.viscosity, params.viscosity);
            gl.uniform1f(locs.showGrid, showGrid ? 1.0 : 0.0);
            
            // Set Navier-Stokes texture uniforms
            if (locs.velocityField !== null) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, velocityRead);
                gl.uniform1i(locs.velocityField, 0);
            }
            if (locs.dyeField !== null) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, dyeRead);
                gl.uniform1i(locs.dyeField, 1);
            }
            if (locs.simResolution !== null) {
                gl.uniform2f(locs.simResolution, SIM_WIDTH, SIM_HEIGHT);
            }
            if (locs.fractalType !== null) {
                gl.uniform1f(locs.fractalType, fractalType);
            } else {
                console.warn('Fractal type uniform is null! Cannot change fractal type.');
            }
            if (locs.stageShape !== null) {
                gl.uniform1f(locs.stageShape, params.stageShape);
            }
            if (locs.maskShape !== null) {
                gl.uniform1f(locs.maskShape, params.maskShape);
            }
            
            // Set grid rotation matrix (pattern rotation)
            const rotMat = rotationMatrix3D(rotation.pitch, rotation.yaw, rotation.roll);
            gl.uniformMatrix3fv(locs.rotation3D, false, rotMat);
            
            // Set camera rotation matrix (perspective/view direction)
            const cameraMat = rotationMatrix3D(cameraRotation.pitch, cameraRotation.yaw, cameraRotation.roll);
            if (locs.cameraRotation !== null) {
                gl.uniformMatrix3fv(locs.cameraRotation, false, cameraMat);
            } else {
                console.error('Camera rotation uniform not found!');
            }
            
            gl.uniform2f(locs.res, canvas.width, canvas.height);
            
            // Use fixed pattern scale based on reference resolution (1080px height)
            // This ensures patterns maintain the same visual size across all devices
            // Original scale was: resolution.y * 0.08, so for 1080px that's 86.4
            // We keep this constant regardless of actual screen size
            const REFERENCE_PATTERN_SCALE = 1080.0 * 0.08; // 86.4
            if (locs.patternScale !== null) {
                gl.uniform1f(locs.patternScale, REFERENCE_PATTERN_SCALE);
            }
            
            // Update debug info
            if (debug && showGrid) {
                debug.textContent = `Time: ${time.toFixed(2)}\nRes: ${canvas.width}x${canvas.height}\nZoom: ${params.zoom.toFixed(2)}\nMode: ${params.displayMode === 0 ? 'Hyperbolic' : params.displayMode === 1 ? 'Parabolic' : 'Elliptical'}\nNavier-Stokes: ON`;
            }
            
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>

